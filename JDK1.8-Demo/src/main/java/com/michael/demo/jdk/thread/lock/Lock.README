
1. 单线程不需要锁，不存在线程安全问题

2. 当多个线程需要同时对同一数据进行修改操作时需要加锁 —— 锁的范围越小越好，锁内的业务越简单越好，执行越快越好

3. JAVA中锁的类型：

        乐观锁(基本上都是基于CAS机制实现。获取时不加锁，修改前判断当前值在运算期间是否有被修改，无修改才更新)

        悲观锁(如 synchronized 关键字。获取数据时加锁，修改完释放锁)
            AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如RetreenLock。
            ConcurrentHashMap 中的 Segment 继承自ReenTrantLock

        相关文章：https://blog.csdn.net/zqz_zqz/article/details/70233767

4. 锁的特性：

        排他性：只有一个线程能获取到(主要特性)。
        阻塞性：其它未抢到的线程阻塞，直到锁释放出来之后再抢。
        可重入性：线程获取锁后，后续是否可重复获取该锁。

4. JAVA中的普通锁只能针对同一JVM虚拟机内部，如果是多个JVM抢占资源，需要使用 分布式锁

5. 分布式锁的实现思路原理：

        计算机计数中，哪些技术能技术排他性？

            文件系统
            数据库：主键 唯一约束 for update
            缓存 Redis : setnx
            zookeeper : 类文件系统 使用临时顺序节点+watcher机制 实现(当对应Client与Zookeeper服务器断开连接时，临时文件会被删除)

        上述都可以用来实现分布式锁

6. 分布式锁 —— 基于数据库

    性能较差，容易出现单点故障   锁没有的失效时间，容易死锁

7. 分布式锁 —— 基于缓存

    实现复杂，存在死锁(或短时死锁)可能

8. 分布式锁 —— 基于Zookeeper

    实现相对简单  可靠性好    性能较好